import glob
import os
import ast
import sys
import json

from collections import Counter

sys.setrecursionlimit(1000000)


CODE_DIR = "python_top_code"
OUT_DIR = "stats"


def make_dir_ignore_exists(d):
    try:
        return os.mkdir(d)
    except FileExistsError as E:
        pass


def decode_data(data):
    try:
        data = data.decode("utf8")
        return data
    except UnicodeDecodeError:
        pass
    data = data.decode("ISO-8859-1")
    return data


def gen_repo_asts(repo):
    ok = 0
    bad = 0
    for file in glob.glob(f"{CODE_DIR}/{repo}/*.py"):
        data = open(file, "rb").read()
        data = decode_data(data)

        if "generated" in data[:1024]:
            print(f"skipping file {file}: autogenerated")
            continue

        try:
            yield ast.parse(data)
            ok += 1
        except Exception:
            bad += 1

    print(f"ast generation finished: ok {ok}, bad {bad}")


def gen_ast_subnodes(ast_node):
    for child in ast.iter_child_nodes(ast_node):
        yield child
        yield from gen_ast_subnodes(child)


def save_counter(repo, filename, counter):
    make_dir_ignore_exists(OUT_DIR)
    make_dir_ignore_exists(f"{OUT_DIR}/{repo}")
    with open(f"{OUT_DIR}/{repo}/{filename}", "w") as f:
        for k, v in counter.most_common():
            print(v, k, file=f)


c = Counter()
class_keywords_c = Counter()
class_bases_c = Counter()
class_decorators_c = Counter()
function_decorators_c = Counter()
async_function_decorators_c = Counter()
exception_handlers_c = Counter()
attributes_c = Counter()
func_names_c = Counter()
async_func_names_c = Counter()
class_names_c = Counter()
module_names_c = Counter()
from_module_names_c = Counter()

repo = sys.argv[1].replace("/", "_")
for cur_ast in gen_repo_asts(repo):
    for ast_node in gen_ast_subnodes(cur_ast):
        name = type(ast_node).__name__
        c[name] += 1

        if isinstance(ast_node, ast.For):
            if ast_node.orelse:
                c["bay_for_with_else"] += 1
        elif isinstance(ast_node, ast.While):
            if ast_node.orelse:
                c["bay_while_with_else"] += 1
        elif isinstance(ast_node, ast.ClassDef):
            has_metaclass = False

            for keyword in ast_node.keywords:
                if keyword.arg == "metaclass":
                    has_metaclass = True

                class_keywords_c[f"{keyword.arg}={ast.unparse(keyword.value)}"] += 1

            if has_metaclass:
                c["bay_class_with_metaclass"] += 1

            bases = [ast.unparse(b) for b in ast_node.bases]

            if bases and bases != ["object"]:
                c["bay_class_with_bases"] += 1

            if bases:
                class_bases_c.update(bases)
            else:
                class_bases_c["<no_base_class>"] += 1

            decorators = [ast.unparse(b) for b in ast_node.decorator_list]

            if decorators:
                c["bay_class_with_decorators"] += 1

            if decorators:
                class_decorators_c.update(decorators)
            else:
                class_decorators_c["<no_decorators>"] += 1

            if ast.get_docstring(ast_node):
                c["bay_class_with_docstring"] += 1

            class_names_c[ast_node.name] += 1

        elif isinstance(ast_node, ast.Try):
            has_handlers = ast_node.handlers
            has_final = ast_node.finalbody
            has_else = ast_node.orelse

            except_type = "bay_try"
            if has_handlers:
                except_type += "_except"
            if has_final:
                except_type += "_finally"
            if has_else:
                except_type += "_else"

            c[except_type] += 1

        elif isinstance(ast_node, ast.FunctionDef):
            decorators = [ast.unparse(b) for b in ast_node.decorator_list]

            if decorators:
                c["bay_functions_with_decorators"] += 1

            if decorators:
                function_decorators_c.update(decorators)
            else:
                function_decorators_c["<no_decorators>"] += 1

            if ast.get_docstring(ast_node):
                c["bay_functions_with_docstring"] += 1

            func_names_c[ast_node.name] += 1

            if ast_node.returns:
                c["bay_functions_annotation_in_returns"] += 1


        elif isinstance(ast_node, ast.AsyncFunctionDef):
            decorators = [ast.unparse(b) for b in ast_node.decorator_list]

            if decorators:
                c["bay_async_functions_with_decorators"] += 1

            if decorators:
                async_function_decorators_c.update(decorators)
            else:
                async_function_decorators_c["<no_decorators>"] += 1

            if ast.get_docstring(ast_node):
                c["bay_async_functions_with_docstring"] += 1

            async_func_names_c[ast_node.name] += 1

            if ast_node.returns:
                c["bay_async_functions_annotation_in_returns"] += 1

        elif isinstance(ast_node, ast.Assign):
            if isinstance(ast_node.value, ast.Yield):
                c["bay_assign_yield"] += 1
            if isinstance(ast_node.value, ast.YieldFrom):
                c["bay_assign_yield_from"] += 1
        elif isinstance(ast_node, ast.ExceptHandler):
            except_type = ast_node.type

            try:
                exception_handlers_c[ast.unparse(except_type)] += 1
            except Exception:
                pass
        elif isinstance(ast_node, ast.Attribute):
            attributes_c[ast_node.attr] += 1
        elif isinstance(ast_node, ast.Import):
            modules = [ast.unparse(b) for b in ast_node.names]
            module_names_c.update(modules)
        elif isinstance(ast_node, ast.ImportFrom):
            from_module_names_c[ast_node.module] += 1
        elif isinstance(ast_node, ast.arg):
            if ast_node.annotation:
                c["bay_arg_annotation"] += 1


save_counter(repo, "stat_ast.txt", c)
save_counter(repo, "stat_class_keywords.txt", class_keywords_c)
save_counter(repo, "stat_class_bases.txt", class_bases_c)
save_counter(repo, "stat_class_decorators_c.txt", class_decorators_c)
save_counter(repo, "stat_function_decorators_c.txt", function_decorators_c)
save_counter(repo, "stat_async_function_decorators.txt", async_function_decorators_c)
save_counter(repo, "stat_exception_handlers.txt", exception_handlers_c)
save_counter(repo, "stat_attributes.txt", attributes_c)
save_counter(repo, "stat_func_names.txt", func_names_c)
save_counter(repo, "stat_async_func_names.txt", async_func_names_c)
save_counter(repo, "stat_class_names.txt", class_names_c)
save_counter(repo, "stat_module_names.txt", module_names_c)
save_counter(repo, "stat_from_module_names.txt", from_module_names_c)
